/*
 * Free Font Converter Copyright (c) 2017, Douglas Rocha Ferraz <rochaferraz[at]gmail.com>
 * based on original code
 * Copyright (c) 2015, Ari Suutari <ari[at]stonepile.fi>.
 * All rights reserved.
 *
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

#include <stdio.h>
#include <getopt.h>
#include <ft2build.h>
#include FT_FREETYPE_H
#include <stdbool.h>
#include <strings.h>
#include "fontHeader.h"
#include <math.h>

/// height of font in pixels
static float fontSize = 10;
/// dots per inch. 72 makes it 1pt = 1px
static int dpi = 72;
/// struct that holds the new font information while rendering
static font_t newFont;
/// light mode is a type of rendering available in Freetype2 library
static int useLightMode = 0;

// General functions
// -----------------

/// max number of two ints
static int max(int a, int b) {
    return (a > b ? a : b);
}

/// returns 4 types of symbols for inputs in range of 0 - 255
char* getSymbol(unsigned char input) {
    unsigned char c = (input >> 6);
    switch (c) {
        case 0: return "  ";
        case 1: return ". ";
        case 2: return ": ";
        case 3: return "* ";
        default: return "  ";
    }
}

// Output C-language code that can be used to include
// converted font into embedded systems application
// ------------------------------------------------

/// dumps the loaded glyphs and font information to a text file
static void dumpFont(const font_t * font, const char* fontFile, float fontSize, int depth) {

    char fontName[80];
    char fileNameBuf[80];
    const char* baseName;
    char outFileName[80];
    char* ptr;
    FILE* out;


// Generate name for font by stripping path and suffix from filename
// ----------------------------------------------------------------------------

    baseName = fontFile;
    ptr = strrchr(baseName, '/');
    if (ptr)
        baseName = ptr + 1;

    strcpy(fileNameBuf, baseName);
    baseName = fileNameBuf;
    ptr = strchr(baseName, '.');
    if (ptr)
        *ptr = '\0';

    sprintf(fontName, "%s_%1.0f", baseName, fontSize);
    sprintf(outFileName, "%s_%1.0f.h", baseName, fontSize);

    out = fopen(outFileName, "w");
    if (!out) {

        perror(outFileName);
        exit(2);
    }

// Headers
// ----------------------------------------------------------------------------

    fprintf(out, "#ifndef FONT_%s_H_%1.0f \n", baseName, fontSize);
    fprintf(out, "#define FONT_%s_H_%1.0f \n\n", baseName, fontSize);

    fprintf(out, "#include \"../include/fontHeader.h\"\n\n");

    fprintf(out, "/* Disclaimers\n"
                 " * ============================================================================\n"
                 " *\n"
                 " * Generated by Free Font Converter\n"
                 " * Converted by %s from example.ttf\n"
                 " *\n"
                 " * Options --size=%d --bitdepth=%d", fontFile, (int)fontSize, depth);
    if (dpi > 0)
        fprintf(out,
                 " --dpi=%d\n", dpi);
    fprintf(out, " *\n"
                 " * For copyright info, see original font file\n"
                 " *\n"
                 " */\n\n");

    fprintf(out, "// Glyphs for all characters\n");
    fprintf(out, "// ============================================================================\n"
                 "\n");

    /// current character being analysed
    uint16_t ch;

    // iterates on all characters
    for (ch = CHARMAP_FIRST_CHAR; ch <= CHARMAP_LAST_CHAR; ch++) {

        // Glyph bitmaps
        // --------------------------------------------------------------------

        // current byte being read
        int inputByte = 0;

        glyph_t currentChar = font->glyphs[ch-CHARMAP_FIRST_CHAR];

        fprintf(out, "// Glyph 0x%x: %c\n",ch,ch);
        fprintf(out, "// -------------\n");

        fprintf(out, "static uint8_t glyph_data_%s_%x[%i] = {\n",fontName, ch,
                currentChar.byteWidth*currentChar.glyphHeight);
        for (int row = 0; row < currentChar.glyphHeight; row++) {
            fprintf(out, "        ");
            // procedures of depth 1 and 8 are similar because glyphs in FT2 are either 1 or 8 bits deep
            if ((depth == 1) || (depth == 8)) {
                for (int outputByte = 0; outputByte < currentChar.byteWidth; outputByte++) {

                    if (outputByte > 0)
                        fprintf(out, ",");

                    fprintf(out, "0x%02x", currentChar.data[inputByte]);
                    ++inputByte;

                    // last char does not have a comma
                    if (outputByte == (currentChar.byteWidth - 1)) {
                        if (row == (currentChar.glyphHeight - 1)) {
                            fprintf(out, "     // ");
                        } else {
                            fprintf(out, ",    // ");
                        }
                    }
                }

                // returns all bytes to write the comments
                inputByte -= currentChar.byteWidth;

            // now the odd cases of depth 2 and 4...
            } else if ((depth == 2) || (depth == 4)) {
                /// counter of bytes in the output glyph
                int outputByte = 0;
                int nbitsUsed = (8/depth);
                /// width of output glyphs
                int outputWidth = ceil(((double)currentChar.byteWidth) / nbitsUsed);

                for (outputByte = 0; outputByte < outputWidth; outputByte++) {

                    uint8_t outputChar = 0;

                    if (outputByte > 0)
                        fprintf(out, ",");

                    if (depth == 2) {
                        outputChar |= (currentChar.data[inputByte] & 0xC0);
                        if ((inputByte + 2) - (currentChar.byteWidth*(row + 1)) <= 0)
                            outputChar |= ((currentChar.data[inputByte + 1] & 0xC0) >> 2);
                        if ((inputByte + 3) - (currentChar.byteWidth*(row + 1)) <= 0)
                            outputChar |= ((currentChar.data[inputByte + 2] & 0xC0) >> 4);
                        if ((inputByte + 4) - (currentChar.byteWidth*(row + 1)) <= 0)
                            outputChar |= ((currentChar.data[inputByte + 3] & 0xC0) >> 6);
                    } else { // depth == 4
                        outputChar |= (currentChar.data[inputByte] & 0xF0);
                        // take care of not making recirculation on next row. If number of next reference to
                        // inputByte (that is, inputByte + 1 + 1, as it is 0-based index) is greater than the number
                        // of characters in the current row, it does not use it for calculation, as it would in fact use
                        // the bytes from the next row
                        if ((inputByte + 2) - (currentChar.byteWidth*(row + 1)) <= 0)
                            outputChar |= ((currentChar.data[inputByte + 1] & 0xF0) >> 4);
                    }
                    inputByte += nbitsUsed;

                    fprintf(out, "0x%02x", outputChar);

                    // last char does not have a comma
                    if (outputByte == (outputWidth - 1)) {
                        if (row == (currentChar.glyphHeight - 1)) {
                            fprintf(out, "     // ");
                        } else {
                            fprintf(out, ",    // ");
                        }
                    }
                }

                // returns all bytes to write the comments
                inputByte -= (outputByte * nbitsUsed);
            }

            // comments
            // ----------------------------------------------------------------

            // chars

            for (int outputChar = 0; outputChar < currentChar.byteWidth; outputChar++) {
                switch (depth) {
                    case 8:
                        fprintf(out, "%s", getSymbol(currentChar.data[inputByte]));
                        break;
                    case 4:
                        fprintf(out, "%s", getSymbol((currentChar.data[inputByte] & 0xF0)));
                        break;
                    case 2:
                        fprintf(out, "%s", getSymbol((currentChar.data[inputByte] & 0xC0)));
                        break;
                    default:
                        for (uint8_t bitCount = 0; bitCount < 8; bitCount++) {
                            fprintf(out, "%c", ((currentChar.data[inputByte] << bitCount) & 0x80) ? '*' : ' ');
                        }
                        break;
                }
                ++inputByte;
            }

            fprintf(out,"\n");
        }

        // by default, byteWidth is the number of pixels because FT2 outputs grayscale on a 0-255 scale. Since there
        // is a reduction to 4 or 2 bits, the width also becomes smaller
        switch (depth) {
            case 2:
                currentChar.byteWidth = ceil(((double)currentChar.byteWidth) / 4);
                break;
            case 4:
                currentChar.byteWidth = ceil(((double)currentChar.byteWidth) / 2);
                break;
            default:
                break;
        }

        fprintf(out, "};\n\n");

        // Glyph info
        // ----------

        fprintf(out, "static const glyph glyph_%s_%x = {\n"
                     "        glyph_data_%s_%x,\n"
                     "        %3d,                                             // glyphHeight\n"
                     "        %3d,                                             // charWidth\n"
                     "        %3d,                                             // byteWidth\n"
                     "        %3d,                                             // glyphLineOffset\n"
                     "        %3d,                                             // glyphColumnOffset\n"
                     "};\n\n",
                fontName,
                ch,
                fontName,
                ch,
                currentChar.glyphHeight,
                currentChar.charWidth,
                currentChar.byteWidth,
                currentChar.glyphLineOffset,
                currentChar.glyphColumnOffset);
    }

    // Font definition
    // ---------------

    fprintf(out, "// Font definition\n"
                 "// ============================================================================\n\n");

    fprintf(out, "static const font font_%s = {\n"
                 "        // glyphs\n"
                 "        {\n",
            fontName);


    // iterates again on all characters to output the vector table of all glyphs
    for (ch = CHARMAP_FIRST_CHAR; ch < CHARMAP_LAST_CHAR - 1; ch++) {       // note that this uses < and not <=
        fprintf(out,
                 "                glyph_%s_%x, /* %c */\n", fontName, ch, ch);
    }
                                                                            // because the last char is different
    fprintf(out, "                glyph_%s_%x  /* %c */\n", fontName, CHARMAP_LAST_CHAR,
            CHARMAP_LAST_CHAR);

    fprintf(out, "        },\n");
    fprintf(out, "        %d,  // bitsPerPixel\n"
                 "        %1.0f  // charHeight\n"
                 "};\n\n", depth, fontSize);

    fprintf(out, "#endif //FONT_%s_H_%1.0f \n", baseName, fontSize);
    fclose(out);

    fprintf(stdout, "%s_%d.h file generated\n",baseName, font->charHeight);
}

/// renders the font according to input parameters
static font_t *convertFont(const char *font, int dpi, float fontSize, int depth)
{
    /// placeholder for error output checks
    int error;
    FT_Face face;
    FT_Library library;

 // Initialize freetype library, load the font
 // and set output character size
 // ------------------------------------------

    error = FT_Init_FreeType(&library);
    if (error) {
        fprintf(stderr, "ft init err %d\n", error);
        exit(1);
    }

    error = FT_New_Face(library,
                        font,
                        0,
                        &face);

    if (error) {
        fprintf(stderr, "ft faceerr %d\n. Are the filename & path right?", error);
        exit(1);
    }

// If DPI is not given, use pixels to specify the size
// ----------------------------------------------------------------------------

    // in general, 72dpi is convenient, for it makes 1px = 1pt. For more info on the calculations of font metrics
    // (enough for writing a dissertation) check Freetype2 tutorials online

    if (dpi != 72)
        error = FT_Set_Char_Size(face, 0, fontSize * 64, dpi, dpi);
    else
        error = FT_Set_Pixel_Sizes(face, 0, fontSize);

    if (error) {
        fprintf(stderr, "set pixel sizes err %d\n", error);
        exit(1);
    }

    int row, col;
    int ch;

    // sets font metrics to font struct
    newFont.bitsPerPixel = depth;
    newFont.charHeight = fontSize;

// Renders characters and puts into font struct
// ----------------------------------------------------------------------------

    // index of char in output
    uint32_t outputIndex = 0;

    // runs the loop on each char
    for (ch = CHARMAP_FIRST_CHAR; ch <= CHARMAP_LAST_CHAR; ch++) {

        // loads glyph
        FT_Int32 ft_load_target = (depth == 1 ? FT_LOAD_TARGET_MONO : (useLightMode ? FT_LOAD_TARGET_LIGHT :
                                                                       FT_LOAD_TARGET_NORMAL));
        error = FT_Load_Char(face, ch, ft_load_target);
        if (error) {
            fprintf(stderr, "load char err %d\n", error);
            exit(1);
        }

        // renders glyph
        FT_Int32 ft_render_mode = (depth == 1 ? FT_RENDER_MODE_MONO : (useLightMode ? FT_RENDER_MODE_LIGHT :
                                                                       FT_RENDER_MODE_NORMAL));
        error = FT_Render_Glyph(face->glyph, ft_render_mode);
        if (error) {
            fprintf(stderr, "glyph render err %d\n", error);
            exit(1);
        }

        // allocates memory for glyph
        newFont.glyphs[ch-CHARMAP_FIRST_CHAR].data = malloc(face->glyph->bitmap.pitch * face->glyph->bitmap.rows);

        // sets other paramenters on glyph
        newFont.glyphs[ch-CHARMAP_FIRST_CHAR].glyphHeight = face->glyph->bitmap.rows;
        newFont.glyphs[ch-CHARMAP_FIRST_CHAR].byteWidth = face->glyph->bitmap.pitch;
        newFont.glyphs[ch-CHARMAP_FIRST_CHAR].glyphLineOffset = fontSize - face->glyph->bitmap_top;
        newFont.glyphs[ch-CHARMAP_FIRST_CHAR].glyphColumnOffset = face->glyph->bitmap_left;
        newFont.glyphs[ch-CHARMAP_FIRST_CHAR].charWidth = face->glyph->advance.x >> 6;

        // iterates on rows
        for (row = 0; row < face->glyph->bitmap.rows; row++) {

            // iterates on columns
            for (col = 0; col < face->glyph->bitmap.pitch; col++) {
                uint8_t* buffer = (uint8_t*) face->glyph->bitmap.buffer;

                // currentByte is the current input byte that holds the pixel information
                uint8_t currentByte = buffer[row * face->glyph->bitmap.pitch + col];

                //int xpos, ypos;
                //xpos = col + face->glyph->bitmap_left;
                //ypos = row + face->height - face->glyph->bitmap_top;

                // outputs to bitmap
                newFont.glyphs[ch-CHARMAP_FIRST_CHAR].data[outputIndex] = currentByte;

                outputIndex++;
            }
        }

        // resets the byte counter of output glyph
        outputIndex = 0;
    }

    return &newFont;
}

static char* fontFile = NULL;

/* options descriptor */
static struct option longopts[] = {
        {"dpi", optional_argument, NULL, 'd'},
        {"size", optional_argument, NULL, 's'},
        {"font", required_argument, NULL, 'f'},
        {"bitdepth", optional_argument, NULL, 'b'},
        {"uselightmode", no_argument, NULL, 'l'},
        {NULL, 0, NULL, 0}
};

static void usage()
{
    fprintf(stderr, "\n"
                    "    ____               ______            __  ______                           __           \n"
                    "   / __/_______  ___  / ____/___  ____  / /_/ ____/___  ____ _   _____  _____/ /____  _____\n"
                    "  / /_/ ___/ _ \\/ _ \\/ /_  / __ \\/ __ \\/ __/ /   / __ \\/ __ \\ | / / _ \\/ ___/ __/ _ \\/ ___/\n"
                    " / __/ /  /  __/  __/ __/ / /_/ / / / / /_/ /___/ /_/ / / / / |/ /  __/ /  / /_/  __/ /    \n"
                    "/_/ /_/   \\___/\\___/_/    \\____/_/ /_/\\__/\\____/\\____/_/ /_/|___/\\___/_/   \\__/\\___/_/     \n"
                    "                                                                                           \n"
                    " \n"
                    "freeFontConverter --font=fontfile [--bitdepth=1] [--size=10] [--dpi=72] [--uselightmode]\n\n"
                    "Font sizes are given in pixels. Light mode is a type of rendering algorithm. \nCheck Freetype2 "
                    "docs for more information on light rendering");
    fprintf(stderr, "\n");
}

int main(int argc, char **argv)
{
    int ch;
    int depth = 1;

    while ((ch = getopt_long(argc, argv, "", longopts, NULL)) != -1) {

        switch (ch) {
            case 'f':
                fontFile = optarg;
                break;

            case 's':
                sscanf(optarg, "%f", &fontSize);
                break;

            case 'd':
                dpi = atoi(optarg);
                break;

            case 'b':
                sscanf(optarg, "%d", &depth);
                break;

            case 'l':
                useLightMode = 1;
                break;

            case 0:
                break;

            default:
                usage();
                exit(1);
        }
    }

    argc -= optind;
    argv += optind;


    if (fontFile == NULL || fontSize == 0) {
        usage();
        exit(1);
    }

    const font_t *font;

    font = convertFont(fontFile, dpi, fontSize, depth);
    dumpFont(font, fontFile, fontSize, depth);
}